2020. 02. 12

1. 비동기 병행 프로세스
 프로세스 여러 개가 동시게 실행되면 병행 프로세스라고 한다. 병행 프로세스는 서로
 관련없이 단독으로 작업을 수행하기도 하지만, 종종 다른 프로세스들과 협력, 통신하면
 서 작업을 진행해야 할 필요가 있다.
 
 cat test.txt | grep rock-climbing
 위의 명령으로 2개의 프로세스 cat과 grep이 만들어지며 cat은 정보를 주고 grep은 정보
 를 받으면서 서로 병행 처리한다.

 2개 혹은 그 이상의 프로세스들이 공유 메모리에 읽기/쓰기를 하고 그 결과가 어떤 프로세스
 가 언제 실행하느냐에 따라 결과가 달라질 수 있는 상황을 경쟁 조건(race condition)이라 한다.

  1.1 상호 배제와 임계 영역
   상호 배제(mutual exclusion)란 한 프로세스가 공유 메모리 혹은 공유 파일을 사용하고
   있을 때 다른 프로세스들이 사용하지 못하게 배제시키는 제어 기법을 말한다. 수행 순서를
   잘 조절해서 2개 이상의 프로세스가 임계 영역에 동시에 들어가지 않게 한다면 경쟁 조건을
   피할 수 있다.

   공유 메모리가 참조되는 프로그램의 부분을 임계 영역(critical section)이라 한다.

   공유 메모리를 사용하는 병렬 프로세스들이 올바르고 효과적으로 수행되려면 다음의 
   상호 배제를 하려는 4가지 요구 조건이 필요하다.
    * 상호 배제 조건 : 두 개 이상의 프로세스들이 동시에 임계 영역에 있어서는 안 된다.
    * 진행 조건 : 임계 구역 바깥에 있는 프로세스가 다른 프로세스의 임계 구역 진입을 막아서는 안 된다.
    * 한계 대기 조건 : 어떤 프로세스도 임계 구역으로 들어가는 것이 무한정 연기되어서는 안 된다.
    * 동일 속도 조건 : 프로세스들의 상대적인 속도에 어떠한 가정도 하지 않는다.
          
   동시에 시도하여 임계 구역으로 들어가는 프로세스를 승리자(winner)라고 부른다.
   승리자는 무작위로 선택되어서 기아 상태를 일으킬 수도 있고 한계 대기 조건을 만족시키게 선택될 수도 있다.

  1.2 2개 프로세스의 상호 배제

2. 세마포어
 2.1 세마포어 연산
  세마포어 s는 정수값을 갖는 변수로서 초기화 및 2개의 연산(P와, V 혹은 wait와 sinal)으로만 접근할 수 있는 특수한 변수이다.
  
  wait(혹은 P)와 signal(혹은 V)의 정의는 다음과 같다.
 
  s.wait() :
         if ( s.value > 0)then
	    s.value--;   -> 임계구역 진입
         else 
	    현재의 프로세스를 s.list에서 기다린다. -> 대기
  s.signal() :
         if ( 1개 이상의 프로세스가 s에서 대기 중이면) then
               그중 1개 프로세스만 진행
         else
	   s.value++;

  프로세스가 wait 연산을 실행하고 세마포어 s 값을 조사하여 양수가 아니라면 프로세스는 대기하고,
  양수인 경우에 1을 감소시키고 임계 구역에 진입한다. 다음 제어는 프로세서 스케줄러에 넘기고
  프로세서는 준비 큐에서 다른 프로세서를 선택한다.

  세마포어 s에 의해 블록 또는 대기 중인 프로세스는 다른 프로세스가 signal 연산을 실행해야 재시작할 수 있다.
  이때, 프로세스는 wakeup 동작에 의해 재시작되고 대기 상태에서 준비 상태로 변하면서 준비 큐에 놓인다.

  임계 영역에 있던 프로세스는 sinal 연산을 실행하여 s를 단순히 1만큼 증가시키고 임계 영역을 빠져나온 사실을 알린다.
   
  wait와 signal 연산이 세마포어 변수를 수정하는 것은 개별적으로 실행된다. 즉 한 프로세서가 세마포어 변수 s를 수정하면
  다른 프로세스는 같은 변수 s에 대하여 수정할 수 없다.

  하드웨어 명령의 비분할 명령(indivisible instruction)이란, 그 명령이 수행되는 동안 인터럽트나 다른 사건(또는 이벤트)으로
  결코 명령이 중단되지 않는 것으로 이러한 명령어를 원자적(atmoic) 명령이라고도 한다.

  세마포어는 0과 1의 값만을 갖는 2진(binary) 세마포어, 그 이외의 정수값을 갖는 계수형(counting) 세마포어가 있다.

 2.2 세마포어를 이용한 상호 배제의 구현
  세마포어는 프로세스 N개의 임계 영역 문제를 다루는데 사용되며, 구현은 다음과 같다.
  
  semaphore s(1);
  while (1) {
          ---
          s.wait();
          // 임계 영역 (critical sectio)
          ---
          s.signal();
          ---
  }
  
  세마포어 변수 s에 적용된 wait와 signal 연산은 동시에 두 가지 동작이 실행되는 것을 예방한다.
  만일 여러 개의 프로세스가 s.wait()를 동시에 호출해도 단 1개의 프로세스만이 s.wait()의 then 부분을 수행하고,
  나머지 프로세스들은 else 절을 수행한다. 또한 else 절을 수행할 프로세스는 대기한다.
  구현 방법에 따라서 세마포어는 무한 대기 상황이 일어나지 않게 보장한다.

 2.3 세마포어를 이용한 동기화
  한 프로세스가 입출력을 요구하면 입출력이 끝날 때까지 그 프로세스는 블록 상태가 된다. 
  그러면 다른 프로세스는 이 블록된 프로세스를 깨워야 한다. 이러한 것을 block/wakeup 프로토콜이라 한다.

  wakeup 시킬 프로세스 P0             block 될 프로세스 P1
  ...                                            ...
  synch.singnal();                          synch.wait();
  ...                                            ...    
  
  semaphore synch(0);
  synch가 0으로 초기화되었으므로 P1 프로세스는 wait() 연산을 할 수 없고, P0 프로세스가 signal() 연산을 실행한 다음에만 수행될 수 있다.

 2.4 세마포어의 구현
   wait()를 호출한 프로세스는 CPU 자원을 반납하고 대기한다. 즉 블록 상태로 들어간다.
   이때 PCB는 세마포어의 블록 리스트에서 대기한다. 다른 프로세스가 signal()을 호출해 주면
   대기하고 있던 프로세스 중 하나는 블록 상태에서 준비 상태로 상태가 변화되고 CPU를 점유하려고 기다린다(wakeup).
   
   class semaphore {
      public:
        wait();
        signal();
      protected:
        int value;
        PCB *list;
   };
   각 세마포어는 정수값과 프로세스 리스트를 갖는다. 프로세스가 세마포어에서 대기하도록 하려면 프로세스(PCB)를 리스트에 추가한다.
   signal()은 대기 프로세스의 리스트에서 한 프로세스를 꺼내어 실행하게 한다.
  