컴퓨터 구조론

2020.02.10 

2장. CPU의 구조와 기능
CPU는 기억장치에 저장되어 있는 프로그램 코드인 명령어들을 실행함으로써
'프로그램 수행'이라는 기능을 수행한다. 그 과정으로는

(1). 명령어 인출 : 기억장치로부터 명령어를 읽어온다.
(2). 명령어 해독 : 수행해야 할 동작을 결정하기 위하여 명령어를 해독한다.
(3). 데이터 인출 : 명령어 실행을 위하여 데이터가 필요한 경우에는 기억장치
혹은 I/O 장치로부터 그 데이터를 읽어온다.
(4). 데이터 처리 : 데이터에 대한 산술적인 혹은 논리적 연산을 수행한다.
(5). 데이터 저장 : 수행한 결과를 저장한다.

첫번째와 두번째 동작은 모든 명령어들에 대하여 공통적으로 수행되지만,
나머지 동작들은 명령어에 따라 필요한 경우에만 수행된다.

2.1 CPU의 기본 구조
CPU는 산술논리연산장치(ALU), 레지스터 세트, 제어 유니트(Control unit)로 구성된다.

ALU : 각종 산술 연산들과 논리 연산들을 수행하는 회로들로 이루어진 하드웨어 묘둘이다.

레지스터 : CPU 내부에 위치한 기억장치로서, 액세스 속도가 컴퓨터의 기억장치들 중에서 가장 빠르다.
               지정된 용도로만 사용되는 특수 목적용 레지스터들과 적은 수의 일반 목적용 레지스터들만이 포함된다.

제어 유니트 : 인출된 프로그램 코드(명령어)를 해석하고, 그것을 실행하기 위한 제어 신호들을 순차적으로 발생하는 하드웨어 모듈이다.
                  즉, 명령어 실행에 필요한 각종 정보들의 전송 통로와 방향을 지정해주고, CPU 내부 요소들과 시스템 구성 요소들의 동작 시간도 결정해준다.

CPU 내부 버스 : CPU 내부 구성요소들 간의 정보 전송 통로이다. 이러한 내부 버스 선들은 외부의 시스템 버스와는 직접 연결되지 않으며, 반드시 버퍼 레지스터
                     혹은 인터페이스 회로를 통하여 시스템 버스와 접속된다.

* 모듈 : 보다 작고 이해할 수 있는 단위로 나뉘어진 것으로 그 자체로 하나의 완전한 기능을 수행할 수 있는 독립된 실체로 본다.
* RISC(Reduced Instruction Set Computer) : 단순하고 고정길이의 명령어 집합을 제공하여, 크기를 줄이고 속도를 높이고자한 CPU 구조
 CPU 명령어 수 및 형식을 단순화하여, 하드웨어 만으로 실행시켜 속도를 높이는 구조

2.2 명령어 실행
명령어 사이클 : CPU가 한 개의 명령어를 실행하는 데  필요한 전체 과정이다.
명령어 인출 단계와 명령어 실행 단계로 이루어진다.
그리고 그 단계를 각각 부사이클로 구분하여 인출 사이클과 실행 사이클로 부른다.

CPU 내부 레지스터
(1). 프로그램 카운터(PC) : 다음에 인출될 명령어의 주소를 가지고 있는 레지스터이다.
  명령어가 인출된 후에는 자동적으로 1(혹은 명령어의 길이에 해당되는 주소 단위의 수만큼)
  증가되며, 분기 명령어가 실행되는 경우에는 그 목적지 주소로 갱신된다.

(2). 누산기(AC) : 데이터를 일시적으로 저장하는 레지스터이다. 이 레지스터의 비트 수는 CPU가
  한번에 연산 처리할 수 있는 데이터 비트의 수, 즉 단어 길이와 같다.

(3). 명령 레지스터(IR) : 가장 최근에 인출된 명령어가 저장되어 있는 레지스터이다.

(4). 기억장치 주소 레지스터(MAR) : 프로그램 카운터에 저장된 명령어 주소가 시스템 주소 버스로 출력되기 전에
  일시적으로 저장되는 주소 레지스터이다. 즉, 이 레지스터의 출력 선들이 주소 버스 선들과 직접 접속된다.

(5). 기억장치 버퍼 레지스터(MBR) : 기억장치에 저장될 데이터 혹은 기억장치로부터 읽혀진 데이터가 일시적으로 
  저장되는 버퍼 레지스터이다. 이 레지스터의 입력 및 출력 선들은 데이터 버스 선들과 직접 접속된다.

* 클록 : 컴퓨터의 모든 부품들은 일정한 간격(속도)으로 발생되는 전기적 신호에 맞추어 동작을 하는데, 이 전기적 신호를 클록이라고 한다.
* 스레드 : 프로세스보다 작은, 실행 흐름의 최소 단위를 이야기한다. 1개의 프로세스는 1개의 프로그램을 실행하는데 1개의 프로그램에서 복잡한 동시 작업을 하기 위해 프로세스를 더 작은 단위로 나눈 것이다.
* 버퍼 : 데이터를 한 곳에서 다른 한 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리의 영역이다.
           버퍼의 상당수는 소프트웨어에 설치되며 네트워크 상에서 자료를 주고받거나,
           스피커에서 소리를 재생할 때, 또는 디스크 드라이브와 같은 하드웨어의 입출력을 결합하는데 자주 이용된다.
* 캐시 : CPU에 비해서 상대적으로 속도가 느린 메인메모리부터 데이터를 불러 들이는 시간을 단축하기 위해서 한번 활용한 데이터의 내용이나 램에서의
          위치를 저장해 놓은 임시 기억장치로 메인메모리보다 훨씬 빠른 속도로 작동하는 고속 메모리의 일종이다.
* 버퍼와 캐시의 공통점 : 추가적인 메모리를 소모함으로써 속도 차이를 보상함.
  버퍼와 캐시의 차이점 : 버퍼는 데이터를 사용 후 폐기한다. 
                                캐시는 한 번 저장한 것은 계속해서 저장하여 가지고 있으며 
                                접근 요청이 발생할 때마다 그 기억 매체를 불러온 쪽에 
                                반환할 수 있다.
* 레지스터 : CPU에서 연산(계산)에 사용하는 데이터를 기억하는 소규모 기억장치를 말한다.
컴퓨터는 캐시로부터 데이터를 읽어들여 레지스터에 저장한 다음 레지스터 사이로 데이터를 전달하면서 연산을 수행한다.

2.2.1 인출 사이클
인출 사이클에서 각 단계별로 수행되는 동작을 마이크로-연산으로 표현하면 다음과 같다.
*마이크로-연산 : CPU 클록의 각 주기 동안 수행되는 기본적인 동작
t0 : MAR <- PC
t1 : MBR <- M[MAR], PC <- PC +1
t2 : IR <- MBR

2.2.2 실행 사이클
명령어는 CPU가 수행할 연산을 지정해주는 연산 코드와 그 연산의 수행에 필요한 오퍼랜드로 구성되며, 오퍼랜드는 명령어가 사용할 데이터가 저장되어 있는 기억장치의 주소를 가리킨다.
          |연산 코드|오퍼랜드(addr)|

CPU가 수행하는 연산들
(1). 데이터 이동 : CPU와 기억장치 간 혹은 CPU와 I/O 장치 간에 데이터를 이동한다.
(2). 데이터 처리 : 데이터에 대하여 산술 혹은 논리 연산을 수행한다.
(3). 데이터 저장 : 연산결과 데이터 혹은 입력장치로부터 읽어들인 데이터를 기억장치에 저장한다.
(4). 프로그램 제어 : 프로그램의 실행 순서를 결정한다.

LOAD addr
t0 : MAR <- IR(addr)
t1 : MBR <- M[MAR]
t2 : AC <- MBR

STA addr
t0 : MAR <- IR(addr)
t1 : MBR <- AC
t2 : M[MAR] <- MBR

ADD addr
t0 : MAR <- IR(addr)
t1 : MBR <- M[MAR]
t2 : AC <- AC + MBR

JUMP addr
t0 : PC <- IR(addr)

2.2.3 인터럽트 사이클
인터럽트 : CPU로 하여금 현재 진행 중인 프로그램 처리를 중단하고 다른 프로그램을
처리하도록 요구하는 메커니즘으로서, CPU와 외부장치들 간의 상호작용을 위하여 
필요한 기능이다. 이러한 인터럽트 요구를 처리해주기 위해 수행되는 프로그램 루틴을
인터럽트 서비스 루틴(ISR)이라고 한다. 또한 인터럽트 요구가 들어왔는지 검사하고, 그
처리에 필요한 동작들을 수행하는 과정을 인터럽트 사이클이라고 한다.

* 스택 메모리 : 동적 자동 메모리
- 지역 변수, 매개 변수, 함수 호출 등에 관여되는 자동 변수가 저장되는 영역
주로, 블록 내 생성된 지역 변수를 처리하기 위해 사용됨
함수가 종료되면 자동으로 할당된 공간이 소멸됨
운영체제, 컴파일러 등이 자동으로 관리해 줌

* 힙 메모리 : 동적 메모리 할당
-주로, 어플리케이션이 운영체제로부터 미리 할당 받은 메모리 영역으로써,
그 영역 안에서 어플리케이션이 사용할 수 있는 일정한 메모리 공간
즉, 프로그램 실행 중에, 동적 할당되는 메모리 영역(프로그래머에 의함)

스택 포인터(SP) : CPU 내부에 있는 특수 목적용 레지스터들 중의 하나로 항상 스택의
최상위(TOS)의 주소를 가르킨다. SP의 초깃값은 주기억장치의 마지막 주소로 세트된다.

다중 인터럽트 : 어떤 외부 장치를 위한 인터럽트 서비스 루틴의 명령어들이 실행되고 있는 동안에
다른 외부 장치가 인터럽트 요구를 발생할 수도 있는데, 이것을 다중 인터럽트라고 한다.
다중 인터럽트를 처리하는 방법으로는 두가지가 있다.

첫 번째 방법은 CPU가 인터럽트 서비스 루틴을 처리하고 있는 도중에는 새로운 인터럽트 요구가
들어오더라도 인터럽트 사이클을 수행하지 않도록 하는 것이다. 이렇게 되면, 그 루틴을 처리하는 동안에
발생한 인터럽트 요구는 대기 상태로 남아 있다가, CPU가 다시 인터럽트 가능 상태로 바뀐 후에 인식된다.

두 번째 방법은 인터럽트 요구들 간에 우선순위를 정하고, 우선순위가 낮은 인터럽트 요구를 처리하고 있는
동안에 우선순위가 더 높은 인터럽트 요구가 들어오면, 현재의 인터럽트 서비스 루틴의 수행을 중단하고 
새로운 인터럽트를 처리하도록 하는 것이다. 스택에 원래의 주 프로그램으로 복귀하기 위한 주소뿐 아니라,
첫 번째 인터럽트 서비스 루틴으로 복귀하는데 사용될 주소도 저장되어야 한다.

2.2.4 간접 사이클
간접 사이클이란 실행 사이클에서 사용될 데이터의 실제 주소를 기억장치로부터 읽어오는 과정으로
인출 사이클과 실행 사이클 사이에 위치한다. 간접 사이클은 항상 수행되는 것이 아니며, 명령어 내의
특정 비트가 1로 세트된 경우에만 수행된다. 

t0 : MAR <- IR(addr)
t1 : MBR <- M[MAR]
t2 : IR(addr) <- MBR

2.3 명령어 파이프닝
명령어를 실행하는데 사용되는 하드웨어를 여러 개의 독립적인 단계들로 분할하고,
그들로 하여금 동시에 서로 다른 명령어들을 처리하도록 함으로써 CPU의 성능을 
높여주는 기술을 말한다. 명령어 파이프라인은 분할되는 단계의 수가 많아질수록
처리 속도가 높아진다.

다음에 실행될 명령어을 미리 인출하는 것을 명령어 선인출 혹은 인출 중복이라고 한다.

2.3.1 2-단계 명령어 파이프라인
명령어 실행 하드웨어를  두 단계로 분리시킨 것을 2-단계 명령어 파이프라인이라고 부른다.
2-단계 명령어 파이프라인의 최대 속도 향상은 2배에 접근하게 되는데 그러기 위해서는
명령어의 인출과 실행에 같은 길이의 시간이 소요되는 경우에만 얻을 수 있다. 실행 단계
에서는 오퍼랜드를 읽거나 저장하기도 하고, 복잡한 연산을 수행하는 경우도 있기 때문에
실행 단계에서 소요되는 시간이 인출 단계보다 더 길다.

2.3.2 4-단계 명령어 파이프라인
파이프라인 단계들의 처리 시간이 동일하지 않음으로 인하여 발생하는 효율저하를 방지하는
방법은 처리 시간이 더 긴 파이프라인 단계를 여러 개로 분할함으로써, 단계들의 처리 시간이 
거의 같아지도록 하는 것이다.

* 명령어 인출 : 명령어를 기억장치로부터 인출한다.
* 명령어 해독 : 해독기를 이용하여 명령어를 해석한다.
* 오퍼랜드 인출 : 기억장치로부터 오퍼랜드를 인출한다.
* 실행 : 지정된 연산을 수행하고, 결과를 저장한다.

파이프라인 단계의 수를 k, 실행할 명령어들의 수를 N
파이프라이닝을 이용한 경우의 전체 명령어 실행 시간 T는
T = k +(N-1)이다.

속도 향상(Sp)은 Sp = k * N / k + (N-1)

k-단계 파이프라인을 이용하면 최대 k배의 속도 향상을 얻을 수 있다.
하지만 여기에는 4가지의 문제점이 있다.

1. 모든 명령어들이 파이프라인 단계들을 모두 거친다고 가정하였지만, 항상 그렇지는 않다.
2. 파이프라인 클록은 처리 시간이 가장 오래 걸리는 단계를 기준으로 정해져야 한다.
3. IF 단계와 OF 단계는 모두 기억장치(혹은 캐시)를 액세스해야 하는데, 하나의 기억장치 모듈을
   두 단계가 동시에 액세스할 수 없기 때문에 둘 중의 하나는 지연될 수밖에 없다.
* 기억장치 충돌 : 두 개 이상의 하드웨어 모듈들이 동시에 기억장치 액세스를 시도하는 상황
4. 조건에 따라 다른 위치로 분기하도록 하는 조건 분기 명령어가 실행된다면, 미리 인출되어
   파이프라인에서 처리되고 있던 명령어들이 무효화될 수 있다는 것이다.

두 번째 문제점을 보완하기 위한 방법으로서, 파이프라인 단계들을 더욱 작게 분할함으로써
처리 시간의 차이를 최소화시켜주는 슈퍼파이프닝 기술이 널리 사용되고 있다. 최근에는 대부분의 
프로세서들이 10단계 이상의 단계들로 분할된 명령어 파이프라인 구조를 사용하고 있다.

세 번째 문제점을 보완하기 위하여 파이프라인의 IF 단계와 OF 단계가 직접 액세스하는
CPU 내부 캐시(internal cache)를 명령어 캐시와 데이터 캐시로 분리시키는 방법이 사용되고 있다.

상태 레지스터 : 연산처리 결과(부호, 올림수 등) 및 시스템 상태를 가리키는 비트들을 저장하는 레지스터
조건 분기 명령어에서 사용하는 조건들은 CPU 내부의 상태 레지스터에 저장되어 있고, 각 조건의 상태를
나타내는 비트를 플래그라고 부르는데, 그들을 모아둔 곳이다.

* 슈퍼바이저 모드 : 운영체제를 포함한 시스템 프로그램을 수행하는 모드
* 사용자 모드 : 사용자 프로그램 혹은 응용 프로그램이 수행되는 모드

2.3.3 슈퍼스칼라
슈퍼스칼라는 CPU의 처리 속도를 더욱 높이기 위하여 내부에 두 개 혹은 그 이상의
명령어 파이프라인들을 포함시킨 구조를 말한다. 매 클록 주기마다 각 명령어 파이프라인이
별도의 명령어를 인출하여 동시에 실행할 수 있다.

* 데이터 의존성 : 한 명령어를 실행한 다음에, 그 결과값을 보내주어야 다음 명령어의 실행이 가능한 관계

두 개의 파이프라인들로 이루어진 구조를 2-way 슈퍼스칼라라고 부르는데, 이 경우에는 매 주기마다 명령어가
두 개씩 인출되어 동시에 처리된다는 것을 확인할 수 있다. 하지만 유의할 점으로는 동시에 처리할 명령어들이
서로 간에 영향을 받지 않고 독립적으로 실행될 수 있어야 한다는 것이다. 다시 표현하면, 두 명령어들 사이에
데이터 의존성이 존재하지 않아야 그들을 동시에 실행할 수 있다.

2.3.4 듀얼 코어 및 멀티 코어
* 프로세스와 스레드의 차이점 : 프로세스는 운영체제로부터 자원을 할당받는 작업의 단위이고
스레드는 프로세스가 할당받은 자원을 이용하는 실행의 단위입니다. 한 프로세스 내에세 동작되는
여러 실행의 흐름으로 프로세스 내의 주소 공간이나 자원들을 같은 프로세스 내에 스레드끼리 
공유하면서 실행된다. 

스레드를 사용하는 이유는 운영제체 시스템의 자원을 효율적으로 관리하기 위해서 사용한다.
멀티 스레드로 실행할 경우, 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로
관리할 수 있고, 프로세스 간의 통신보다 스레드 간의 통신의 비용이 적으므로 작업들간의 통신의 부담이 줄어들게
된다. 하지만 자원 공유는 전역 변수를 이용하므로 동기화 문제에 신경을 써야한다.

CPU 코어 : 기존의 CPU 칩에 포함되던 하드웨어 중에서 명령어 실행에 반드시 필요한 핵심 모듈들을 말한다.
명령어 파이프라인들로 이루어진 슈퍼스칼라 모듈과 ALU 및 레지스터 세트 등을 말한다. 그러한 CPU 코어 
여러 개를 하나의 칩에 넣은 것을 멀티-코어 프로세서라고 부른다.

듀얼 코어에서는 각 CPU 코어가 슈퍼스칼라 명령어 파이프라인에 비하여 독립성이 더 높다.
각 CPU 코어는 별도의 하드웨어 모듈로 구현된 상태로 하나의 칩에 포함되며, 시스템 버스 
인터페이스와 내부 캐시만 공유한다. 따라서 각 CPU 코어는 프로그램 실행을 독립적으로 수행하며,
필요한 경우에만 공유 캐시를 통해 정보를 교환한다.
 
듀얼 코어 프로세스에서는 독립적인 처리가 가능한 단위로 분할된 태스크 프로그램들이
CPU 코어들에 의해 동시에 처리된다. 이와 같은 프로그램 동시처리 기술을 멀티-태스킹
혹은 멀티-스레딩이라고 부른다.

2.4 명령어 세트
어떤 한 CPU를 위해 정의되어 있는 명령어들의 집합을 명령어 세트라 한다.

명령어 세트를 설계하기 위해서는 다음과 같은 사항들을 먼저 결정해야 한다.
* 연산 종류 : CPU가 수행할 연산들의 수와 종류 및 복잡도
* 데이터 형태 : 연산이 수행될 데이터들의 형태. 즉, 데이터의 길이와 수의 표현 방식
* 명령어 형식 : 명령어의 길이, 오퍼랜드 필드들의 개수와 길이 등
* 주소지정 방식 : 오퍼랜드의 주소를 지정하는 방식

2.4.1 연산의 종류
데이터 전송
산술 연산
논리 연산
입출력(I/O)
프로그램 제어 : 명령어 실행 순서를 변경하는 연산으로 분기와 서브루틴이 있다.
서브루틴 호출에는 호출하는 CALL 명령어와 복구시키는 RET 명령어가 있다.
둘다 스택을 반드시 사용해야 된다.

CALL X 명령어
t0 : MBR <- PC
t1 : MAR <- SP, PC <- X
t2 : M[MAR] <- MBR, SP <- SP -

RET 명령어
t0 : SP <- SP + 1
t1 : MAR <- SP
t2 : PC <- M[MAR]

2020.02.11

2.4.2 명령어 형식
* 연산 코드 : 수행될 연산을 지정해준다.
* 오퍼랜드 : 연산을 수행하는데 필요한 데이터 혹은
데이터의 주소를 나타낸다. 각 연산은 한 개 혹은 두
개의 입력 오퍼랜드들과 한 개의 결과 오퍼랜드를 가질
수 있다. 데이터는 CPU 레지스터 혹은 기억장치에 위치한다.
* 다음 명령어 주소 : 현재의 명령어 실행이 완료된 후에
다음 명령어를 인출할 위치를 나타낸다. 분기 혹은 호출
명령어와 같이 실행 순서를 변경하는 경우에만 필요하다.

명령어 형식 : 명령어를 구성하는 비트들은 용도에 따라
몇 개의 필드들로 나눌 수 있는데, 필드의 수와 배치 방식
및 각 필드에 포함되는 비트 수를 정의한 것이다.

명령어의 길이, 즉 비트 수는 일반적으로 CPU가 한 번에
처리할 수 있는 데이터 즉, 단어의 길이와 같다.

연산 코드의 비트의 수는 CPU가 수행할 수 있는 
연산들의 수를 결정해준다. 연산 코드의 비트의 수가
4비트라면 CPU는 2의4승 총 16가지의 연산들을 수행
할 수 있다.

명령어의 길이가 고정된 상태에서 어느 한 필드의 비트
수를 증가시키면, 다른 필드의 비트 수는 그만큼 줄어들게
된다.

오퍼랜드 필드에는 세 가지 중의 어떤 것인지에 따라 필요한 비트 수가 달라질 수 있다.
* 데이터 : 표현 가능한 수의 크기가 결정된다.
* 기억장치 주소 : CPU가 오퍼랜드 인출을 위하여 직접 주소를 지정할 수 있는 기억장치
                       영역의 범위가 결정된다.
* 레지스터 번호 : 데이터 저장에 사용될 수 있는 내부 레지스터들의 수가 결정된다.

CPU가 처리할 수 있는 연산의 종류는 명령어 세트와 하드웨어 설계 과정에서 결정한다.

명령어가 한개의 오퍼랜드만 포함하는 것을 1-주소 명령어라 한다.

명령어에 두개의 오퍼랜드를 포함하는 것을 2-주소 명령어라고 한다.

세 개의 오퍼랜드들을 명령어 내에 포함하는 것을 3-주소 명령어라고 한다.

2.4.3 주소지정 방식
일반적으로 명령어 비트의 수는 CPU가 처리하는 단어의 길이와 같도록 제한된다.

제한된 수의 명령어 비트들을 이용하여 사용자(혹은 프로그래머)로 하여금 가능한
다양한 방법으로 오퍼랜드를 지정하고 더 큰 용량의 기억장치를 사용할 수 있도록
하기 위한 방식이 주소지정 방식이다.

1) 직접 주소지정 방식
오퍼랜드 필드의 내용이 데이터의 유효 주소로 사용되는 가장 간단한 방식이다.
EA = A가 되며 데이터 인출을 위하여 한 번의 기억장치 액세스만 필요하다.
일정 부분은 연산 코드를 위해 사용되기 때문에 남은 비트들만 주소 비트로 사용될
수 있다. 직접 액세스할 수 있는 기억장치 주소 공간이 오퍼랜드 필드의 비트 수에 의
해 제한되는 것이 이 방식의 단점이다.

2) 간접 주소지정 방식
명령어의 오퍼랜드 필드의 기억장치 주소(A)가 가리키는 기억 장소에 실제 사용할 
데이터의 유효 주소(EA)를 저장해 두는 방법이다. 최대 기억장치 용량이 그 기억 장소에
저장된 전체 비트 수에 의해 결정되므로, 단어 길이가 n개이면 직접 주소지정 될 수 있는
기억 장소들의 수는 최대 2의n승개 이다. EA=(A)로 표현한다.
간접 비트(I)가 포함되어, 비트가 0이면 직접 주소지정 방식을, 비트가 1이면 간접 주소지정
방식이다. 단점으로는 실행 사이클 동안에 두번 기억장치 액세스가 필요하다는 점이다.

3) 묵시적 주소지정 방식
명령어 실행에 필요한 데이터의 위치를 지정하지 않더라도 이미 묵시적으로 정해져 있다.
예를 들어 PUSH R1 명령어는 레지스터 R1의 내용을 스택에 저장하는데, 이때 스택 포인터
의 내용이 스택의 위치를 지정하는 유효 주소로 사용된다. 가장 큰 장점은 오퍼랜드가 없거나
한 개뿐이기 때문에 명령어 길이가 짧다는 점이다.

4) 즉시 주소지정 방식
연산에서 사용할 데이터를 명령어 코드 내에 포함하고 있다. 즉, 오퍼랜드 필드의 내용이
연산에 즉시 사용될 수 있는 실제 데이터이다. 이 방식은 프로그램에서 레지스터나 변수의
초기 값을 어떤 상수값으로 세트하는 데 주로 사용된다.
장점으로는 데이터를 인출하기 위하여 기억장치를 액세스할 필요가 없기 때문에 실행 사
이클이 짧아진다는 점이다. 단점으로는 사용할 수 있는 수의 크기가 오퍼랜드 필드의 비트 
수에 의해 제한된다는 점이다.

5) 레지스터 주소지정 방식
연산에 사용될 데이터가 레지스터에 저장되어 있다. 따라서 오퍼랜드 필드의 내용은
레지스터 번호로 사용되며, 그 번호가 가리키는 레지스터의 내용이 명령어 실행 과정에서
데이터로 사용된다. EA = R이 된다.
오퍼랜드의 필드가 K비트라면, 2의K승개의 레지스터들이 이 방식을 위하여 사용될 수 있다.
장점으로는 오퍼랜드 필드의 비트 수가 적어도 되고, 데이터 인출을 위하여 기억장치를
액세스할 필요가 없다. 그러나 데이터가 저장될 수 있는 위치가 CPU 내부 레지스터로 제한된다.

6) 레지스터 간접 주소지정 방식
오퍼랜드 필드(레지스터 번호)가 가리키는 레지스터의 내용이 유효 주소가된다. 
EA = (R)이며 지정된 레지스터의 내용이 기억장치 주소로 사용되어 실제 데이터를 인출한다.
주소를 지정할 수 있는 장치 영역은 레지스터의 길이에 달려있다. 이 방식을 이용하면
데이터 인출을 위하여 한 번의 기억장치 액세스가 필요하다.

7) 변위 주소지정 방식
직접 주소지정 방식와 레지스터 간접 주소지정 방식을 조합하면 변위 주소지정 
방식이라는 유연성이 높은 방식을 만들 수 있다. EA = A + (R)로 표현된다.

두 개의 오퍼랜드를 가지는데, 하나는 변위를 나타내는 주소 A이고, 다른 오퍼랜드는 레지
스터 번호 R이다.

사용되는 레지스터에 따라 여러 종류의 변위 주소지정 방식들이 정의될 수 있다.

* 상대 주소지정 방식 
이 방식에서는 레지스터로서 프로그램 카운터가 사용된다. EA = A + (PC)로 표현되고
PC의 내용과 변위 A를 더하여 유효 주소가 결정된다. 그런데 현재 PC의 내용은 다음에
실행할 명령어의 주소이므로, 변위는 그 명령어의 위치를 기준으로 한 상대적인 값이 된다.
A는 일반적으로 2의 보수로 표현된다. 이 방식은 주로 분기 명령어에서 사용되는데, 
변위가 양수은 경우에는 앞 방향으로 분기하고, 음수인 경우에는 반대 방향으로 분기한다.
이 방식을 사용하면 변위의 범위가 오퍼랜드 필드의 비트 수에 의하여 제한되지만, 전체
기억장치 주소가 명령어에 포함되어야 하는 일반적인 분기 명령어보다 적은 수의 비트만
있으면 된다는 장점이 있다. 또한 레지스터로서 PC가 묵시적으로 지정되기 때문에, 명령어
형식에서 R 필드가 필요하지 않다. 따라서 R필드와 A필드가 모두 주소 필드(A)로 사용될 
수 있다.

* 인덱스 주소지정 방식
인덱스 레지스터의 내용과 변위 A를 더하여 유효 주소를 결정한다. 인덱스 레지스터는 인덱스
값을 저장하는 특수 레지스터이다. EA = A + (IX)가 된다. 주소 A는 기억장치에 저장된 데이터
배열의 시작 주소를 가리킨다. 인덱스 레지스터의 내용은 그 배열의 시작 주소로부터 각 데이터
까지의 거리를 나타낸다. 연속된 데이터들을 차례대로 액세스하는 경우를 위하여 명령어
사이클 동안에 레지스터의 내용이 자동적으로 증가 혹은 감소되도록 할 수도 있는데, 이것을
자동 인덱싱이라고 한다. 

* 베이스-레지스터 주소지정 방식
베이스 레지스터의 내용과 변위 A를 더하여 유효 주소를 결정한다. EA = A + (BR)이 된다.
베이스 레지스터에는 기준이 되는 명령어의 주소가 저장된다. 프로그램의 시작 위치를 지정
하는데 사용된다. 만약 프로그램들과 데이터들을 다른 위치로 이동시켜야 하는 경우 베이스
레지스터의 내용만 이동될 위치의 시작 주소로 변경하면 된다.



