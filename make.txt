2020.02.19

make

1. make의 이해
파일 관리 유틸리티

각 파일 간의 종속 관계를 파악해 기술 파일
(Makefile)에 기술된 대로 컴파일 명령이나
셸(shell) 명령을 순차적으로 내린다.
                                                    
make의 장점
1. 컴파일 시간 절약
2. 프로그램의 종속 구조 빠르게 파악
3. 관리가 용이
4. 단순 반복 작업을 최소화

* CMake와의 차이점
CMake는 소스파일 내부까지 들여다보고
분석해서 의존성 정보를 스스로 파악한다는 점
예를 들어, 소스파일에 헤더파일을 추가하면
직후 빌드부터 의존성 관계 변화가 자동으로
추적되어 헤더 파일의 변화까지 추적하기 시작한다.

또한, Makefile에서는 빌드 중간생성물인 
Object파일들의 이름과 의존성 정보까지 모두
기술해 줘야 하지만, CMake에서는 그럴 필요가
전혀 없습니다. CMake의 빌드 스크립트인
CMakeLists.txt에서는 최종 빌드 결과물과
이를 빌드하기 위한 소스 파일들만 명시해
주면 그것으로 끝입니다.(여기서 최종 빌드
결과물은 실행 바이너리나 라이브러리가 됨)


1.1 make의 기본 동작
make 명령 수행 시 make memo.o 명령과
같이 특별한 타겟(make memo.o 명령에서는
memo.o가 타겟임)을 지정하지 않으면 제일
처음 만나는 타겟을 생성하려고 한다. 

make는 모든 타겟에 대해 타겟과 종속 항목들의
수정 시간을 비교해 재컴파일할 필요가 있는지
판단한다. 타겟이 모든 종속 항목의 수정 시간보다
이후에 만들어졌다면 make는 새로 컴파일할 
필요가 없는 것으로 간주하고 그 타겟에 대해서는
컴파일 명령을 수행하지 않는다.

1.2 기술 파일의 작성
1.2.1. 기술 파일의 기본 구조

CC = gcc <- 매크로 정의
target 1 : dependency1 dependency2 <- 롤1
	command1      <- 명령
             command2
target 2 : dependency3 dependency4 <- 롤2
	command3
	command4

기술 파일의 제일 첫 부분은 내부에서 사용할
매크로의 정의 부분이다. 매크로를 기술 파일에서
사용하면 정의된 스트링으로 치환된다.
다음에 오는 것은 규칙 정의 부분인데, 타겟이
오고 콜론 뒤에 그 타겟을 생성하기 위해
필요한 종속 항목들의 리스트가 온다.

보통 종속 항목에 속하는 파일들은 타겟을 
빌드할 소스 파일이나 오브젝트 파일들이다.
다음 행으로 종속 항목들이 충족되었을 때 
타겟을 생성하기 위한 명령 리스트가 온다.
종속 항목이 충족된 상태에서 타겟을 생성하기
위해 make는 나열된 명령을 위에서 아래로 
순차적으로 수행해 타겟을 생성한다.

1.2.2. 기술 파일 구문 작성 기본 규칙
1. 명령의 시작은 반드시 TAB으로 시작되어야 한다.
탭으로 시작되지 않는 명령절을 만나면 make는
명령절을 타겟절로 해석하기 때문에 "*** missing
separator." 혹은 "*** 분리 기호 ..."라는 오류
메시지를 출력하고 수행을 중단할 것이다.

2. 비어 있는 행은 무시된다.
타겟절 이하에 오는 명령절에 있어 비어있는
명령라인은 무시된다.

3. '#'을 만나면 개행 문자를 만날 때까지 무시한다.
기술 파일 내에서 '#'은 셸 스크립트와 마찬가지로
주석의 시작을 의미한다. 그래서 '#' 이후 개행 문자까지
make에 의해 무시된다.
* 개행문자 : 컴퓨터에서 줄바꿈을 나타내는 제어문자

4. 기술 행이 길어지면 '\'를 사용해 이을 수 있다.
셸 스크립트와 마찬가지로 행 끝에 '\'를 만나면
'\'는 공백으로 치환되고 다음 행의 '\'가 있던
바로 뒤에 붙는다.

5. ';'는 명령라인을 나눌 때 사용한다.

6. 종속 항목이 없는 타겟도 사용 가능하다.
종속 항목이 없기 때문에 명령절은 바로 수행된다.
명령절이 정상적으로 수행된 후에 make는 타겟이
실제 파일로 존재하지 않더라도 룰을 해석하는
그 순간만큼은 타겟이 만들어진 것으로 간주한다.

7. 명령 부분에는 어떤 명령이 와도 상관없다.
명령절에는 반드시 컴파일 명령이나 종속 항목과
관계된 명령만 사용하라는 법은 없다. 

2. 매크로의 사용
기술 파일 내에 매크로는 C와 마찬가지로 사용자
정의 변수에 특정한 문자열을 정의하고 표현하는 것을
의미한다. 이후 매크로는 기술 파일 내에 정의된 문자열로
치환되어 사용될 수 있다. 

CC = gcc
CC 매크로를 정의했다면 CC는 기술 파일 
내부에서 $(CC)로 표기함으로써 gcc로 치환
될 수 있다. 

2.1 매크로 작성 기본 규칙
1. 매크로의 정의는 '='를 포함하는 하나의 문장이다.
NAME = string
'='의 좌측에는 매크로 이름이 오고 우측에는
정의 문자열이 온다. 관습적으로 매크로 이름은
대문자를 사용한다.

2.'#'은 주석문의 시작이다.

3. 여러 행을 사용할 때는 '\'를 사용한다.

4. 매크로를 참조할 때는 괄호나 중괄호를
둘러싸고 앞에 '$'를 붙이다.
중괄호는 셸에서 환경 변수 치환에도 사용되기
때문에 셸 환경 변수와의 구분을 위해 괄호의
사용을 권장하는 편이다.

5. 정의되지 않은 매크로를 참조할 때는 null 
문자열로 치환된다.

6. 중복된 정의는 최후에 정의된 값을 사용한다.

7. 매크로 정의 시 이전에 정의된 매크로를
참조해 정의할 수 있다.

8. 여러 대입 기법을 사용할 수 있다.
'='를 사용한 재귀적 확장 매크로는 여러 번
스캔되면서 재귀적으로 확장이 일어난다.
':='는 단 한 번 위에서 아래로 스캔되면서
확장이 일어난다. 그렇기에 정의되지 않은 매크로는
null로 치환된다.
'+='는 기존의 매크로에 공백을 두고 현재의 
문자열을 덧붙인다.
'?='는 현재 정의하는 매크로가 정의되어 있지
않았을 때 정의한다.

2.2 매크로 사용 시 주의 사항
1. 구분을 위해 문자열에 따옴표를 넣으면
따옴표 또한 문자열의 일부로 인식한다.

2. 매크로의 이름에는 ':','=','#'이 들어가서는
안 되고 TAB으로 시작해서도 안 된다.

3. 매크로는 반드시 치환될 위치보다 먼저
정의되어야 한다.

4. '\'나 '<','>'과 같은 셸 메타 문자는
사용을 자제해야 한다.

2.3 내부적으로 정의되어 있는 매크로의 사용
make -p 명령을 셸에서 내리면 make 내부에
정의된 매크로 리스트들이 나열된다.

make 내부적으로 정의되어 있지만 make -p
명령으로 확인할 수 없는 매크로 들이 있는데,
이를 자동 매크로라고 부른다.

target = $@
dependency = $^

3. 확장자 규칙의 사용
.SUFFIXES는 특수 타겟으로 .SUFFIXES의 
종속 항목은 확장자 규칙을 검사하는데
사용되는 확장자들의 리스트다. 그러므로
확장자 규칙을 사용하려는 확장자는 먼저
.SUFFIXES 타겟의 종속 항목으로 설정해야
한다.

이전에 .SUFFIXES를 사용하지 않아도 확장자
규칙이 통용된 이유는 make 내부적으로 중요
확장자에 대해 .SUFFIXES 타겟의 종속 항목으로
이미 등록되어 있기 때문이다.

make에서 %는 일치하는 모든 문자열을 의미

자동 매크로에서 $<와 $*는 확장자 규칙에서 사용된다.
$^는 일반적인 타겟을 생성하기 위한 룰에서는
사용할 수 있지만 확장자 규칙에서는 사용할 수 없다.
반대로 $<는 일반적인 타겟 생성 룰에서는
사용할 수 없고 확장자 규칙에서만 사용할 수 있다.

SRCS 매크로에서 $(wildcard *.c)는 현재 디렉토리에서
*.c와 파일명이 일치하는 파일을 찾아 공백을
구분 문자로 SRCS 매크로에 정의한다.

SRCS = *.c라고 사용하지 않고 SRCS = $(wildcard *.c)
와 같이 사용한 이유는 SRCS = *.c라고 사용하면
매크로를 정의할 때는 와일드카드 확장이 되지 않기 때문이다.
(*.c 식의 와일드카드 확장은 타겟 정의절과 명령절에서만 일어난다.)

$(wildcard *.c)와 같이 사용하는 것을 
make 함수의 사용이라고 한다.

patsubst 함수는 문자열 처리에 사용되는데,
세 번째 인자로 오는 $(wildcard *.c)의 결과인
memo.c calendar.c main.c에서 공백으로 
구분된 문자열들 각각에 대해 첫 번째 인자인
%.c와 매칭되는 것을 %.o로 바꾼다.

4. 더미 타겟의 사용
clean과 같은 타겟을 더미 타겟 또는 Phony
target이라고 한다. 일반적으로 타겟으로 
지정되는 것들은 생성될 파일임에 비해
더미 타겟은 파일이 생성되지 않는 개념적인
타겟을 의미한다.

더미 타겟은 재귀적으로 make를 사용할 때
사용하기도 하고 또 매번 수행해야 될 룰을
정의할 때 사용하기도 한다.

5. 명령 사용 규칙
;을 이용하면 한 라인으로 두 명령을 표현할
수 있다.

&&는 앞의 명령이 성공했을 때 뒤에 오는
명령을 수행하라는 의미이다.

명령 에코 기능이란 명령을 수행할 때 수행되는 
명령을 보여주는 기능 
'@'를 붙이지 않으면 echo 명령도 출력되고
명령의 결과도 출력된다.

모든 명령에 대한 에코 기능을 끌려면 
.SILENT :라는 특수 내장 타겟을 사용한다.

.SILENT 타겟은 특수 내장 타겟으로, .SILENT 
타겟에 등록된 종속 항목에 수행되는 명령
들은 에코 기능을 끄기 때문에 수행되는 
명령이 화면에 출력되지 않는다.

전체 수행 명령에 대한 에코 기능을 끄려면
.SILENT : 만 명시한다.

리눅스에서 main() 함수의 리턴 값이 integer
값이 아니라면 즉, void main() {}이라면
컴파일 시 경고가 뜨는 것을 경험했을 것이다.

main() 함수에서 리턴되는 값은 그 함수를
fork()해 수행시킨 부모 프로세스가 wait()
시스템 콜을 호출할 때 부모 프로세스에
전달된다.

예를 들면 cat file.txt 명령을 수행했을 때 
명령을 받은 셸은 fork() 시스템 콜로 자식
프로세스를 생성하고 그 자식 프로세스가 
execv() 시스템 콜로 cat 명령을 수행한다.

file.txt 파일이 있고 읽기 권한이 있다면
cat 명령은 정상적으로 수행될 것이다.
통상 C 프로그램에서 정상적으로 수행되었을
경우 return 0;를 한다. 그러나 file.txt 파일이
없어 정상적으로 수행되지 못했다면 0이 아닌
다른 값을 리턴할 것이다.

셸에서 바로 직전 명령 수행 후 리턴 값을
보려면 다음과 같이 echo $? 명령으로 확인 
할 수 있다.


make는 명령 한 행을 수행 후 매번 리턴 값을
체크해 0이 아닌 값이 리턴된 경우 수행을 종료한다

명령이 비정상적으로 수행되어 0이 아닌 값이 리턴되더라곻
make 수행을 계속하려면 명령 앞에 '-'를 붙여야 한다.

기술 파일 전체에 대해 명령 오류를 무시하고
싶다면 .IGNORE : 추가한다.

기술 파일 내에서 셸 변수를 참조하려면 $${변수명}
과 같이 '$' 기호를 두 개 붙여주고 중괄호로
묶거나 "$$변수명"과 같이 괄호를 붙이지 않는다.
* '$'를 하나만 붙인다면 매크로로 인식한다.


2020.02.20

3.8 재귀적 make의 사용
3.8.1 여러 디렉토리로 나누어진 소스를 make로 관리하는 기법
1. 일일이 경로를 지정하는 방법
2. VPATH를 사용하는 방법 ( 파일명에 종속되는 경향)
   VPATH 매크로를 지정하면 make가 소스 파일들을 찾을 때 현재 디렉토리뿐만
아니라 VPATH에 등록된 디렉토리에서까지 소스 파일을 찾는다. 그래서 현재 디렉토리에
name.c가 없어도 name 디렉토리에 name.c 파일이 있기 때문에 컴파일할 때 name/name.c를
이용해 아무 이상 없이 컴파일된다. VPATH를 이용해 여러 디렉토리에 있는 소스 파일을
컴파일할 때는 각 서브디렉토리에 Makefile이 없어도 된다.
3. 재귀적인 make 사용법

SUBDIRS 매크로에 서브디텍토리를 등록하면 하나의 타겟에서 셸 스크립트에 의해 
일괄적으로 make 명령을 내릴수 있다. 

3.8.2 서브 Makefile에 대한 매크로 전달
Makefile과 같이 어느 한 매크로만 서브 Makefile에 전달하고 싶으면 매크로 앞에
export 키워드를 붙여준다.

모든 매크로에 대해 전달하고 싶으면 export 키워드를 단독으로 써준다.

3.9 조건부 수행
make에는 ifeq ~ else ~ endif문이 있다.

all :
ifeq ($(CC,gcc) # 내부 정의 매크로 CC는 cc로 되어 있다.
	@echo "C 컴파일러는 GNU gcc입니다."
else
	@echo "C 컴파일러는 $(CC)입니다."  # 이 부분이 수행된다.
endif

ifeq($(CC,gcc)는 $(CC)가 gcc인가를 판단한다. 
그렇다면 @echo "C 컴파일러는 GNU gcc입니다." 수행되고
그렇지 않다면 @echo "C 컴파일러는 $(CC)입니다." 수행된다.
반드시 끝은 endif로 끝나야 한다.

null 문자를 비교하려면 ifeq ($(CC),)처럼 사용 한다.
else 문장은 없어도 된다.

all :
ifeq ($(CC,) 
	@echo "C 컴파일러는 GNU gcc입니다."
endif
	@echo "end"

같지 않은지 비교하고 싶다면 ifneq ~ else ~ endif문을 사용한다.

all :
ifneq ($(CC,gcc) # 내부 정의 매크로 CC는 cc로 되어 있다. # $(CC)가 gcc와 같지 않다면?
	@echo "C 컴파일러는 GNU gcc입니다." # 이 부분이 수행된다.
else
	@echo "C 컴파일러는 $(CC)입니다."  
endif

ifeq문과 ifneq문은 리눅스 커널 Makefile 내에서 사용자가 make menuconfig 시
지정한 커널 옵션으로 파일이나 디렉토리를 선택적으로 매크로에 추가할 때 많이 사용한다.

ifdef ~ else ~ endif문은 매크로가 정의되었는지 되지 않았는지에 따라 Makefile을 다르게
구성할 때 사용한다.
all :
ifdef C
	@echo "CC 매크로는 정의되어 있습니다."
else
	@echo "CC 매크로는 정의되지 않았습니다."
endif

반대로 ifndef ~ else ~ endif문은 매크로가 정의되지 않을 때 수행되는 문장을 정의하고
기본 사용법은 ifdef문과 같다.
all :
ifndef NO_DEFINE
	@echo "NO_DEFINE 매크로는 정의되지 않았습니다."
else
	@echo "NO_DEFINE 매크로는 정의되았습니다."
endif

3.10 함수의 사용
make 함수에는 문자열을 처리하기 위한 함수, 파일 관련 함수, 반복을 위한 함수 등이 있다.

make에서 함수는 다음과 같은 형식으로 사용된다
$(함수명 함수인자들)
$() 기호 내에 함수명이 오고 공백이나 탭 이후에 함수의 인자들이 오는 형태이다.
함수의 인자가 여러 개라면 콤마(,)로 구분된다.

3.10.1 셸 명령 함수
$(shell 셸 명령)
shell 함수는 뒤에 오는 셸 명령을 수행하고 결과를 리턴한다.

SRCS = $(shell ls *.c)

echo :
	@echo $(SRCS)

위와 같은 기술 파일을 작성하고 현재 디렉토리에 kkk.c 파일과 기술 파일만 있는
상태에서 make echo 명령을 내리면 다음고 같이 현재 디렉토리에 있는 C 소스 파일인
kkk.c를 출력해준다.

이런 결과가 나오는 이유는 shell 함수에 의해 ls *.c 명령을 셸에 내린 결과가 SRCS
매크로에 정의되었기 때문이다.

shell 함수는 명령 수행 결과를 매크로로 정의할 때 사용할 수 있는 유일한 방법이다.

3.10.2 문자열 처리 함수
1. 문자열 치환 함수

1.1 $ (subst 찾을 문자, 변경할 문자, 목표 문자)
subst 함수는 목표 문자에서 찾을 문자를 발견하면 변경할 문자로 치환한다.

STR = $(subst like, Like, I like you.)
echo :
	@echo $(STR)
결과로는 I LIKE you.가 된다.

1.2 $(patsubst 패턴, 변경 문자열, 목표 문자열)
patsubst 함수는 목표 문자열에서 패턴을 발견하면 변경 문자열로 변경한다.
패턴에는 %기호를 사용할 수 있는데, %기호는 공백과 탭을 제외한 모든 문자열을 의미한다.
가령 "I like you." 문자열이 있을 때 %ke는 "like" 문자와 일치한다.

STR = $(patsubst %.c, %.o, memo.c main.c ABCD)
echo :
	@echo $(STR)
결과로는 memo.o main.o ABCD로 치환된다.

매크로에서 특정 패턴을 치환하려면 patsubst 함수 대신 다음과 같이 사용할 수도 있다.
$(매크로 명 : 패턴=치환할 문자열)

1.3 문자를 정령하는 함수
$(sort 문자열)
sort 함수는 인자로 오는 문자열에 대한 정렬을 수행한다. 
중복되는 문자열이 있다면 하나의 문자열만 인식한다.

MACRO = bbb aaa ccc aaa ddd
STR = $(sort $(MACRO))

의 결과는 aaa bbb ccc ddd 이다.

1.4 공백 문자의 제거
$(strip 문자열)
strip 함수는 인자로 오는 문자열의 제일 앞에 사용된 공백 문자를 제거하고 각 문자 간에
공백 문자열이 하나 이상 사용되었다면 하나로 만든다.

strip 함수에 의해 "   I   like    you.   "와 같은 문자열은 "I like you. "로 바뀐다.
strip 함수는 ifeq 명령으로 두 문자열을 비교할 때 많이 사용된다.

1.5 문자 필터일 함수
$(filter 패턴, 문자열)
fiter 함수는 패턴과 일치한느 문자열만을 걸러준다. 

FILES = memo.c head.h main.c asm.s diary.h
SRCS = $(filter %.c %.s, $(FILSE))
HEADS = $(filter %.h, $(FILSE))

SRCS =  memo.c main.c asm.s
HEADS = head.h diary.h

$(filter-out 패턴, 문자열)
이 함수는 filter 함수와 반대로 일치하지 않는 문자열만 걸러준다.
위의 결과와 반대로 나온다.

1.6 특정 문자열을 찾는 함수
$(findstring 찾을 문자열, 대상 문자열)
findstring 함수는 대상 문자열에서 찾을 문자열을 찾는다.
그래서 찾으면 찾을 문자열을 리턴하고, 못 찾으면 null 문자를 리턴한다.

STR = aaa bbb ccc
echo :
	@echo bbb : $(findstring bbb, $(STR))
	@echo kkk : $(findstring kkk, $(STR))

bbb : bbb
kkk :                이렇게 나온다.

$(words 문자열)
문자열에서 사용된 단어의 개수를 리턴한다.
그래서 $(words aa bb cc)와 같이 사용되면 3을 리턴한다.

$(word n, 문자열)
문자열에서 n번째 단어를 리턴한다.
$(word 2, I like you.)하면 "like"를 리턴한다.

$(wordlist 시작 번호, 끝 번호, 문자열)
시작 번호부터 끝 번호까지의 단어들을 리턴한다.
$(wordlist 2, 4, aa bb cc dd ee)라고 사용하면 두 번째 단어인 bb부터
4번째 단어인 dd까지 bb cc dd가 리턴된다.

$(firstword 문자열)
문자열에서 첫 번째 단어를 리턴한다. 
$(firstword I like you.)와 같이 사용하면 첫 번째 단어인 I를 리턴한다.

$(join 문자열, 문자열)
앞의 문자열과 뒤에 오는 문자열을 합쳐 하나의 문자열로 만들어낸다.
$(join src asm, .c .s)와 같이 사용하면 src.c asm.s를 리턴한다. 
앞에 오는 문자열의 단어 개수와 뒤에 오는 문자열의 개수가 맞이 않다면
뒤에 남는 단어는 합치지 않고 따로 출력한다.

2. 파일 이름 관련 함수
1. $(dir 문자열)
dir 함수는 문자열에서 디렉토리 부분만 추출한다.
PATHS = /bin/ls /sbin/ifconfig memo/memo.c Makefile
echo :
	@echo $(dir $(PATHS))

결과 : /bin/ /sbin/ memo/ ./

$(notdir 문자열)
notdir 함수는 dir 함수와 반대로 디렉토리가 아닌 부분만 추출한다.
위의 함수에서 notdir로 바꾸고 출력한다면
결과 : ls ifconfig memo.c Makefile

$(suffix 문자열)
문자열에서 확장자만 추출한다.
FILES = src/memo.c asm/asm.S for.f
echo :
	@echo $(suffix $(FILES))

결과 : .c .S .f

$(basename 문자열)
문자열에서 점(.)과 확장자를 제외한 순수한 파일명만 추출한다.
위의 파일에서 이용한다면 결과는 src/memo asm/asm for 이렇게 나온다.

$(addsuffix 접미사, 문자열)
문자열의 각 단어 뒤에 접미사를 붙여준다.

$(addprefix 접두어, 문자열)
문자열에 접두어를 붙여준다.

3. 기타 유용한 함수
1.$(wildcard 패턴)
현재 디렉토리에서 패턴과 일치하는 파일 리스트를 뽑는다.
$(wildcard *.c)라고 사용하면 현재 디렉토리에 있는 모든 .c 파일의 리스트를 리턴한다.

2.$(foreach 변수명, 대입 문자열, 확장 문자열)
변수명에 대입 문자열을 단어별로 대입해 넣고 그 변수를 확장 문자열에서 사용한다.

SRCS = $(foreach str, a b c, $(str) .c)
foreach 함수는 먼저 str 변수에 대입 문자열의 첫 번째 단어인 a를 넣어서 str 변수를
확장 문자열 부분에서 이용한다. 현재 str 변수에는 a가 들어 있기 떄문에 $(str).c는
a.c를 의미한다. 그래서 먼저 a.c가 리턴된다. 그리고 b를 str 변수에 넣고 $(str).c에서 확장한다.
결국 b.c가 리턴된다. 마지막으로 c.c가 리턴되어 최종적으로 a.c b.c c.c가 출력된다.

foreach 함수에서 중요한 것은 단어의 개수만큼 반복한다는 것이다.
SRCS = $(foreach str, a b c, TEXT)
결과는 TEXT TEXT TEXT로 TEXT 문자열이 a b c 단어 개수만큼 출력된 예다.

주로 다음과 같이 사용되어 반복 확장할 때 유용하다.
SRCS = $(foreach dir, . memo main calendar, $(wildcard $(dir)/*.c))

foreach 함수 내에서 선언된 변수는 foreach 함수 내에서만 유효하다는 점을 기억하길 바란다.

$(origin 매크로명)
매크로가 어떻게 정의된 매크로인지에 관한 문자열을 리턴한다.

4. 함수를 사용할 때 주의 사항
1. 함수는 함수를 지원하는 make에서 사용해야 된다.
함수를 기술 파일에서 사용하면 이미 그 기술 파일은 함수를 지원하는 make로만 종속된다.
그래서 이식성을 해칠 수 있다. 이런 부분은 여러 기계에서 동작할 수 있는 Makefile을 
생성하는 소스 패키징 유틸리티인 automake에서 문제가 된다. 함수를 지원하지 않기 때문이다.

2. 함수의 인자로 콤마(,)와 공백()을 사용할 때 주의해야 한다.
콤마를 인자로 사용하려면 comma 매크로를 따로 정의해야 한다.
comm =,
TEXT = id, pass, name
STR = $(subst $(comma) '_' $(TEXT))
echo :
	@echo $(STR)

공백 역시 인자로 사용하려면 공백을 매크로로 정의하고 나서 사용해야 한다.
spac = $(null) $(null)

null 매크로는 당연히 이전에 정의되지 않은 매크로다. 이렇게 정의되지 않는 매크로는
매크로 치환 시 null 문자열로 치환된다. 결국 null 문자 사이의 공백 문자만이 space 
매크로로 정의된다. 이때 주의할 점은 마지막 $(null) 뒤에는 공백을 넣어서는 안 된다는 점이다.
공백이 추가되면 뒤에 추가된 공백만큼 space 매크로으의 문자열로 정의된다.

3.11 특수 타겟
.DEFAULT : make가 요청된 타겟을 빌드할 룰을 기술 파일 또는 확장자 규칙에서 찾지 못하면
.DEFAULT 타겟에 기술된 명령을 수행한다.

.IGNORE : 명령 수행 시 반환되는 오류 코드를 무시한다. make 명령 시 i 옵션을 준것과 
동일하고, 기술 파일 내에서 모든 명령 앞에 '-' 기호를 붙여준 것과 동일하다.

.PRECIOUS : .PRECIOUS 타겟에 기술된 파일들은 빌드 중단 신호 또는 명령라인에서 오류가
반환되더라도 지우지 않는다.

.SILENT : 명령은 실행하지만 실행되는 명령을 화면에 출력하지는 않는다. -s 옵션과 동일하고
 모든 명령 앞에 '@'를 붙인 것과 동일하다.

.SUFFIXES : .SUFFIXES 타겟에 정의된 확장자들은 중요 확장자들로, 확장자 규친과 연관될 수 있다.

.EXPORT_ALL_VARIABLES : 재귀적 make 사용법에 있어 export 키워드를 단독으로 기술
파일에서 사용한 것과 마찬가지로 기술 파일 내의 모든 매크로들을 하위 기술 파일에 전달 한다.


