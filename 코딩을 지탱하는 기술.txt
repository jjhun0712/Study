코딩을 지탱하는 기술

2020.02.29

1. 효율적으로 언어 배우기

1.1 비교를 통한 배움

많은 언어에서 공통적으로 사용되는 개념이야말로 중요한 지식이다.

규칙은 언어마다 다르다

C 언어와 Ruby의 참 거짓 값
'C 언어에서는 0이 거짓이고, 그 이외의 값은 참이다'와 'Ruby에서는 false와 nil이 거짓이고, 0을 포함한
그 이외의 값은 참이다'

Java의 참거짓 값
Java에서는 참거짓 값을 위한 형을 가지고 있어서 조건식에서도 그 형을 사용하지 않으면 안 된다.
0은 단순히 정수형을 의미하기 때문에 조건식에 0을 사용하게 되면 컴파일 에러가 발생한다.
즉, 세상에는 0이 참인 언어, 0이 거짓인 언어, 0이 참도 거짓도 아닌 언어가 존재하고 있는 것이다.

1.2 역사를 통한 배움

언어 설계자의 의도를 이해하자

어떤 언어를 배워야 하는지는 아무도 모른다
언어에 의존하지 않는 보편적인 지식의 습득
몇가지 언어를 비교하거나 언어의 역사나 이유를 조사함으로, 언어가 바뀌어도 통용할 수 있는 이해력을
기를 필요가 있다.

1.3 정리

'비교를 통한 배움'이란 특정 언어로 프로그래밍을 배우는 것이 아니라, 다수의 언어를 비교해 가면서
학습하는 것을 의미한다. 무엇이 언어에 따라 다르고 무엇이 공통적인지 배울 수 있다.

'역사를 통한 배움'이란 언어가 어떻게 바뀌었고 바뀌기 전에는 어떤 의문점이 존재했는지 학습한느 것을
의미한다. 이를 통해, 언어가 가지고 있는 다양한 기능이 '왜' 탄생했는지 배울 수 있다.

2. 프로그래밍 언어를 조감하다

2.1 프로그래밍 언어 탄생의 역사
프로그래밍 언어는 인간을 편하게 하기 위해 만들어졌다.

케이블을 연결하다
1946년 ENIAC(Electronic Numerical Integrator and Computer)이 발명됐다. 이 컴퓨터는 '무엇을 계산할지'
, 즉 목적에 따라 프로그램을 변경할 수 있었다. 17,468개의 진공관을 사용한 거대한 컴퓨터로, 그 폭은 24
미터나 됐다. 그리고 이 컴퓨터에 수많은 단자에 케이블을 여기저기 연결하는 것이 프로그래밍이였다. 프로
그램을 변경할 때마다 케이블의 연결을 바꾸는 것은 매우 힘든 일이였다.

프로그램 내장 방식으로
1949년 EDSAC(Electonic Delay Storage Automatic Calculator)이 개발됐다. 이것은 테이프에 구멍을 뚫어서
데이터를 표현하고, 컴퓨터가 이를 읽어 들이도록 한 구조다. 프로그램 자체도 데이터로서 입력된다. 물리적
케이블을 교환하는 대신, 종이 테이프의 데이터를 읽어 들여서 프로그램을 변경하라 수 있었다. 하지만, 사람이
프로그램을 읽거나 쓰는 것은 여전히 어려웠다. 어디까지나 기계가 읽기 위한 언어, 즉 '기계어'였던 것이다.

FORTRAN의 등장
1954년, 현재 우리가 사용하고 있는 것과 비슷한 프로그래밍 언어가 고안되었다. 바로 FORTRAN이다. 이름은
Formula Translating System(수식 변환 시스템)을 의미한다. 명칭이 의미하듯 '수식을 기계어로 변환하는 것'이
FORTRAN의 특징 중 하나였고 최초로 표현한 것이다.

2.2 프로그래밍 언어 탄생의 목적

나태 - 프로그래머의 삼대 미덕
프로그래밍 언어 Perl의 설계자인 Larry Wall은 프로그래머가 가져야 할 3 가지 자질로서, '나태, 조바심,
자만심'을 제안했다.

나태(Laziness)
전체 에너지 소비를 줄이기 위해 대부분의 능력을 집중하는 기질. 이렇게 노동력을 줄이기 위해 만든 프로그램은
다른 사람들도 사용하게 되며, 그 프로그램에 관한 질문에 일일이 답한느 수고를 덜기 위해 문서를 만들게 된다.
이는 프로그래머에게 있어 가장 중요한 자질이기도 하며, 이 책이 존재하는 이유이기도 하다. 

제 2 미덕인 조바심은 프로그램이 느린 것을 용납하지 않는 것을 의미하며, 제 3 미덕인 자만심은 틀린 것을
방치하지 않음을 의미한다.

Laziness의 요점은 '편하게 하다'이다. 당장에 눈에 보이는 편리함을 요구하는 것이 아니라, 앞날까지 생각해서
가장 편한 방법을 선택하는 것이다. 즉, 같은 성과를 달성하는 다수의 방법 중 가장 생산성이 높은 것을 
선택함을 의미한다.

Perl이라는 이름은 'Practical extraction and report language'(실용적 데이터 취득 및 리포트 작성 언어)라는 
의미이다. Perl은 리포트 작성을 수월하게 하기 위해 만들어진 언어다.

언어에 따라 다른 '편리함'의 의미

무엇을 편하게 하고 싶은 것인가?
---------------------------------------------------------------
C++은 빠른 실행 속도를 중시하고 있는 언어다. C로 만든 코드보다 빠른 속도가 날 수 있도록 고안했지만,
결과적으로 언어 사양이 더 복잡해지고 말았다.

어떤 프로그램을 편하게 만들고 싶은가?
----------------------------------------------------------------
Python은 다른 사람이 쓴 코드를 쉽게 해석할 수 있는 데 중점을 두고 있다. C에 가깝고 프로그래머에게
익숙한 많은 제어 구문을 채용하고 있으며, 인텐드(Intend, 들여쓰기)를 강조하고 있다. 그에 반해 속도가 
느리며, 사양도 단순하지 않다.

예를 들어 PHP는 웹 서비스를 쉽게 만들 수 있도록 해준다. 그러나 문장 처리를 편하게 하지는 못한다.
반대로 Haskell, OCaml 등의 ML(Meta-language) 처리 계통 언어는 ML이라는 이름이 나타내고 있듯이 
문장 처리를 쉽게 만든다. 그러나 웹 서비스를 위해 사용된 경우는 PHP만큼 많지 않다.

2020.02.28

10. 병행 처리

10.1 병행 처리란?

복수의 처리를 시간축 상에 오버랩에서 실행하는 것을 병행 처리라고 한다.

옛날 컴퓨터인 EDSAC 등에서는 프로그램을 입력 후 계산을 실행하면 이후는 계산이
끝날 때까지 기다리는 수 밖에 없었다. 하나의 프로그램 처리가 시작해서 끝날 때까지
컴퓨터는 해당 처리만을 할 수 있었다.

* 프로그래밍 언어에 있어서의 병행성과 하드웨어의 병렬성이란 상호간에 독립된 개념이다.
즉, 병렬성은 하드웨어 측면의 개념이다. 반면 프로그래밍 측면의 병행성의 주안점은 
프로세스나 스레드 등의 개념이다.

편리한 병행 처리를 실현하기 위해 프로세스나 스레드 등의 개념이 만들어졌다.
또한 병행 처리가 원인이 되어 새로운 문제를 일으키게 되자 그 대안 책으로 락이나 
파이버 등의 개념이 발명되었다.

10.2 잘게 분할해서 실행한다.

한 번에 하나의 처리만 실행하는 것보다 복수 개의 처리를 동시에 실행하는 것이 편리하다.
하지만 실행하기 위한 회로(CPU)가 하나 밖에 없는데 어떻게 복수의 처리를 동시에 실행할 수 있는 것일까?

그것은 '사람이 눈치챌 수 없는 짧은 순간에 복수의 처리를 변경해가면서 실행'하기 때문이다.
어떤 순간에는 하나의 처리만 실행되지만, 사람의 눈에는 복수의 처리가 병행해서 동작하고 
있는 듯이 보인다.

이것이 병행 처리의 가장 중요한 개념으로, 사람의 눈으로 보면 프로그램이 계속 동작하고
있는 것처럼 보이지만 실제로는 잘게 분할해서 실행되고 있는 것이다. 

10.3 처리를 변경하는 2가지 방법

1. 협력적 멀티태스크
하나는 '타이밍이 좋은 시점에서 교대'하는 방법이다. 처리가 일단락되는 시점에 자발적으로
처리 교대를 하는 방법이다. 이 방법으로 구현된 멀티 태스크를 협력적 멀티태스크라고 한다.

이 방법에서는 어떤 처리가 '교대해도 좋다'라고 말하지 않고 계속 실행하면 다른 처리는
계속 기다려야 하는 문제점이 있다. 어디까지나 '모든 처리가 최적의 간격으로 교대한다'
는 신뢰 관계를 기반으로 성립하는 시스템이다.

2. 선점적 멀티태스크
다른 한 가지 방법은 '일정 시간에 교대'하는 것이다. 이 방법에서는 개별 프로그램과 
입장이 다른 프로그램(태스크 스케줄러)이 존재한다. 이 프로그램이 일정 시간마다
지금 실행되고 있는 처리를 강제적으로 중단시켜서 다른 프로그램이 실행될 수 있도록 한다.

이 방법으로 구현된 멀티태스크를 선점적 멀티태스크라고 한다. 선점적이란 '타인의 행동을
막기 위한'이란 의미다. 이 기법은 협력적 멀티태스크와 달리 '처리를 멈출 수 있는 프로그램의
협력' 없이도 강제적으로 처리를 중지시킬 수 있는 것이 특징이다.

10.4 경합 상태 방지법

경합 상태는 이 프로그램은 '스레드 세이프가 아니다'라고 표현한다.

경합 상태는 평행해서 동작하고 있는 2가지 처리 간에 경합 상태가 발생하기 위해서는
3가지 조건을 모두 만족해야 한다.
1. 2가지 처리가 변수를 공유하고 있다.
2. 적어도 하나의 처리가 그 변수를 변경한다.
3. 한쪽 처리가 한 단락 마무리 되기 전에, 다른 한쪽의 처리가 끼어들 가능성이 있다.

역으로 말하면, 이 3가지 조건 중 하나라도 제거할 수 있다면 병행 실행 시에도 안정된
프로그램을 만들수 있다.

공유하지 않는다 - 프로세스와 액터 모델
처음부터 아무것도 공유하지 않으면 1번은 발생하지 않기 때문에 경합 상태를 신경 쓸 필요가 없다.

프로세스에서는 메모리를 공유하지 않는다.
-----------------------------------------------
UNIX에서는 실행 중의 프로그램을 '프로세스'라고 부른다. 서로 다른 프로세스는 메모리를
공유하지 않는다. 때문에 복수의 프로그램이 메모리 상에서 경합 상태를 일으킬 일은 없다.
데이터베이스 접속, 파일 읽고 쓰기 등 무엇인가를 공유했을 때만 주의하면 된다.

'프로세스'라는 용어는 UNIX가 탄생하기 전부터 사용되고 있었으며 당시에는 메모리를
공유하고 있어서 지금의 '스레드'와 비슷했다.

UNIX에서는 프로세스 별로 '사용해도 좋은 메모리 영역'을 결정함으로, '다른 프로세스와
메모리를 공유하지 않는다'를 실현하는 구조를 채용했다.
-> 가상 주소 공간

공유하지 않는 접근법은 성공했을까?
----------------------------------------
UNIX는 '하나의 프로세스 안에서 병행해서 실행되는 처리는 하나'라는 구조였다.
즉 복수의 처리를 병행해서 실행하고 싶다면 복수의 프로세스를 구동해야 한다.
서로 다른 프로세스는 메모리를 공유하지 않지만, 이것은 즉 '병행 실행되는 처리는
메모리를 공유하지 않는다'는 것이다.

UNIX 출시 후 약 10년 후 '경량 프로세스'가 만들어진다. 이것은 메모리를 공유하는 
UNIX 이전 방식의 프로레스다. 이것이 나중에 '스레드'라고 불리게 되었다.

액터 모델
----------------------------------------
'메모리를 공유하지 않는다'는 설계 방침에서의 또 다른 흐름이 바로 액터 모델이다.
액터 모델은 1937년에 발표된 병행 처리를 표현하기 위한 모델이다.

병행해서 동작하는 복수의 처리가 정보를 교환하는 방법으로, '메모리를 공유한다'가 아닌
'메시지를 보낸다'를 제안했다.

사무 일을 보는 사람과 서류, 서류 상자로 예들 들자.
A가 책상 위에 서류를 펼쳐놓고 작업을 하고 있을 때 B가 A에 다른 일을 부탁한다고 
하는 상황이다. 서류가 펼쳐진 A의 책상에 B가 서류를 놓는다면 A의 작업에 방해가 될
것이다. 이것이 공유 메모리의 문제점이다. 한편, A의 작업이 한 단락 마무리 될 때까지
B가 옆에서 대기하면 B의 시간을 버리게 된다. 이것이 락의 문제점이다. 그렇지 않고
B가 A의 서류 상자에 서류를 넣고 자신의 자리로 돌아가는 것이 액터 모델이다.

처리는 비동기로 이루어진다. A가 서류 상자 안의 서류를 언제 처리할지 B는 모른다.
언제 처리가 끝나는지도 서류에 '끝나면 B에게 보내라'라고 써놓고 B가 자신의 서류 
상자에 A가 돌려보낸 것을 발견하고 나서야 '끝났구나'하고 알게 되는 것이다.

이런 특징이 잘 맞는 처리가 바로 메시지 교환이다. 트위터나 페이스북 등의 '대량의 
사용자 메시지를 취급한느 서비스'에서는 이 액터 모델이 적합한 처리가 많다.

변경하지 않는다 - const, val, Immutable

'메모리를 공유해도 변경하지 않으면 문제가 없다'는 2번에 대한 대응책도 있다.

모든 값이 변경 불가능한 Haskell이라는 언어가 있다.

한편, 보다 현실적인 타협안으로 '일부 변수를 변경할 수 없게 한다'는 구조를 가진
언어가 많이 있다. 예를 들어 C++에서는 const를 붙여서 변수 선언을 하면 변경할 
수 없는 변수가 된다. 또한 Scala에서는 var와 val의 2가지 변수 선언이 있어서, val로
선언한 것은 변경할 수 없다.

JAVA에서는 Mark Grand가 제안한 디자인 패턴의 하나인 Immutable 패턴이 자주 사용된다.
클래스에 private 필드를 만들어서 그것을 읽어내기 위해 getter 메소드를 만들지만, 
변경하기 위한 방법이 마련되어 있지 않아서 '읽는 것은 가능하나 변경은 안 된다'는 
상황을 구현할 수 있다.

끼어들지 않는다.
협력적 스레드 사용 - 파이버, 코루틴, 그린 스레드
-----------------------------------------------------------------------
스레드가 선점성을 가지고 끼어드는 원인이 되기 때문에 협력적 스레드를 만들면 된다는
생각이다. Ruby의 Fiber 클래스나 JavaScript의 제너레이터가 그 예다.

물론 협력적 멀티태스크이기 때문에 어떤 스레드가 CPU를 독점하면 다른 스레드의
처리가 멈춘다. 어디까지나 각 스레드가 협력적으로 최적의 순간을 맞춘다는 사실을 
전제로 하고 있다.

끼어들면 곤란해지는 처리에 표식을 붙인다 - 락, 뮤텍스, 세마포어
------------------------------------------------------------------------
 다른 한 가지 방법은 '지금 끼어들면 곤란해'라는 표식을 공유하는 것이다. 예를 들어,
어떤 메모리 값이 0이 아니면 이것은 '다른 스레드가 끼어들면 곤란한 처리를 하고 있어'
라고 정해 두는 것이다. 각 스레드는 '끼어들면 문제가 발생하는 처리'를 하기 전에, 우선
해당 메모리 값을 체크한다. 그 값이 0이면 처리를 실행해도 좋고, 0이 아니면 0으로 
바뀌기까지 기다렸다가 처리를 한다.

이 방법에는 여러 가지 기법이 있어서, 락, 뮤텍스, 세마포어 등 다양한 명칭이 있지만 
핵심 개념은 '사용중' 표식과 같다. 

'락'이라는 이름 때문에 '락을 걸어 두면 다른 사람이 들어올 수 없다'고 착각하기 쉽다.
하지만 실제는 '사용중'이라는 표식을 붙여둘 뿐, 표식을 확인하지 않고 실행하는 
스레드가 있으면 아무 소용이 없다. 처리 흐름의 일부 만을 협력적으로 양보하는 
구조라고 볼 수 있다.

'안에 들어갈 때 사용중이란 표식이 있는지 확인, 있으면 대기, 없으면 표식을 걸고 안
으로 들어간다'는 일련의 처리를 바르게 구현하는 것은 쉽지 않은 일이다. 예를 들어
if 문 등으로 만들면 '값을 확인한다'와 '0이면 1로 변환한다' 사이에 별도 처리가 끼어들
가능성이 발생한다. 다른 처리가 끼어들지 못하게 하기 위해 기계어의 '값 확인과 변경을
한 번에 실행하는 명령' 등을 사용할 필요가 생긴다. JAVA의 언어 처리계는 이 기능을
자체적으로 구현해서 채용했다. 이로 인해 JAVA 언어 사용자는 자신이 직접 고생하지 
않고도 'sychronized 블록'으로 감싸기만 하면 손쉽게 락을 걸 수 있게 되었다.

10.5 락의 문제점과 해결책

락의 문제점

교착 상태가 발생한다
--------------------------------------------
공유된 X와 Y를 변경하는 처리 A와 처리 B가 있다고 하자. A가 'X를 락시키고, Y를 락
시킨다'는 순서로 락을 걸어두고, B가 'Y를 락시키고, X를 락시킨다'는 순서로 락을 걸었
을 경우 시점에 따라선 문제가 발생한다. A가 X를 락하고 B가 Y를 락하는 상태에서 
서로가 상대방 락이 풀리는 것을 기다리게 된다.

이것이 교착 상태라고 불리는 현상이다. 이 문제를 방지하기 위해서 프로그래머는
프로그램 전체에서 락의 순서가 일관되도록 주의해야 한다. '무엇에 락을 걸어야 하는가'
뿐만 아니라, '어떤 순으로 락을 걸어야 하는가'도 파악해야 한다.

합성할 수 없다
--------------------------------------------
             X에서 2를 꺼냄             Y에 2를 추가한다
X 2 3     ------------------> X 3   -----------------------> X 3
Y 1                                Y 1                                 Y 1 2
                              어중간한 상태

스레드 세이프 라이브러리에서는 락 제어를 프로그래머가 챙기지 않아도 되도록, 내부에서
락을 사용해 '꺼내는 처리'나 '추가하는 처리'가 끼어들지 못하도록 한다. 하지만 이 락으로는
'X에서 빼내서 Y에 넣는다'는 2가지 명령의 사이에 끼어드는 것을 막을 수는 없다. 끼어
들기를 막기 위해서는 프로그래머가 2가지 처리를 묶는 새로운 락을 만들어서, X나 Y를
읽고 쓰는 모든 코드를 synchronized 블록 등으로 감싸지 않으면 안 된다.

트랜잭션 메모리
이 문제를 해결하려고 하는 것이 트랜잭션 메모리라는 접근법이다. 데이터베이스의 트랜
잭션 기법을 메모리에 적용한 것이다. 개념은 '실험적으로 해보고, 실패하면 처음부터 다시
고쳐서 하고, 성공하면 변경을 공유한다'이다. X나 Y를 직접 변경하는 것이 아니라, 일시적으로
별도 버전을 만들어서 그것을 변경하고 하나의 묶음 처리가 끝나면 반영하는 것이 포인트다.

읽는 처리를 할 때는 아직 일시적으로 만들어진 별도 버전의 변경이 원래 버전에 반영되지 않고,
다른 스레드가 보고 있는 상황은 'X에서 꺼낸다'의 앞 부분이다. 그래서 특별한 문제는
발생하지 않는다.

쓰는 처리가 끼어들면 일시적으로 만들어진 별도 버전은 버리고 다시 처음부터 시작한다.
이와 같이 락을 걸지 않아도 문제 없이 병행 처리가 가능하다. 단, 쓰는 처리의 빈도가 높을 
때는 '다시 고쳐서 하기' 작업이 다발해서 성능이 나빠진다.